# goit-algo-hw-04

Щоб порівняти ефективність алгоритмів сортування злиттям, вставками та Timsort, ми можемо використати модуль timeit у Python для вимірювання часу виконання кожного алгоритму на різних наборах даних. Ось як ми можемо це зробити:

Реалізація алгоритмів: спочатку потрібно реалізувати алгоритми сортування злиттям та вставками, оскільки Timsort вже вбудований у Python (через функції sort() та sorted()).

Генерація наборів даних: для емпіричного тестування алгоритмів сортування потрібно створити різні набори даних, такі як випадкові масиви, відсортовані масиви, і масиви відсортовані у зворотньому порядку, з різною кількістю елементів.

Тестування та вимірювання часу: використання модуля timeit для вимірювання часу виконання кожного алгоритму на різних наборах даних.

Аналіз результатів: порівняння часу виконання кожного алгоритму, щоб визначити їх ефективність у різних сценаріях.

Аналізуючи результати вимірювань часу виконання, можна зробити наступні висновки:

Сортування вставками:

Швидко працює на невеликих масивах та коли масив вже відсортовано, що видно з низького часу виконання для 100 елементів та особливо для відсортованих масивів.
Значно сповільнюється на більших масивах та особливо на масивах, відсортованих у зворотньому порядку, через квадратичну складність в найгіршому випадку.

Сортування злиттям:

Продемонструвало консистентніші та кращі результати, ніж сортування вставками, на великих масивах.
Має логарифмічну складність, тому час виконання зростає не так швидко зі збільшенням розміру масиву.

Timsort:

Виявився найшвидшим у всіх випадках, що підтверджує його ефективність для різних типів даних.
Особливо добре працює на відсортованих та майже відсортованих масивах завдяки оптимізаціям, що базуються на алгоритмах сортування злиттям та вставками.


Висновки:

Timsort виявився набагато ефективнішим у порівнянні з чистими алгоритмами сортування злиттям та вставками, особливо на великих масивах та різних типах даних.
Ефективність Timsort пояснюється його гібридною природою: він адаптується до різних структур даних і використовує переваги обох алгоритмів, з яких він складається.
Ці результати підтверджують, чому у більшості випадків рекомендується використовувати вбудовані алгоритми сортування в Python, які оптимізовані для широкого спектру сценаріїв використання.